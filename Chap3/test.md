# Test



### 1. 함수의 이름을 짓는 방법과 관련하여 책에 서술된 조언을 쓰시오 (500자 이상)

  코드는 단순 명료하게 작성해야 하는데, 이를 위해서는 이름만 보고도 각각 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 작성해야 합니다. 이름을 잘 지으면 함수 이름만 보고도 어떤 식으로 동작하는지 예측할 수 있으며, 헤매는 시간을 크게 절약할 수 있습니다. 따라서 함수의 이름을 지을 때 매우 신경 써서 지어야 합니다.

  함수명은 동작 방식이 아닌 의도와 목적이 드러나게 짓고, 주석으로 설명해야 하는 내용은 함수의 본문에 담습니다. 저자는 주석이 많으면 악취가 난다고 하였는데, 함수명을 잘 짓기만 해도 필요한 주석의 양은 매우 줄어듭니다.

  좋은 이름의 함수를 정의하는 방법은 주석을 이용해 함수의 목적을 설명해보는 것인데, 이러한 과정을 거쳐 주석이 멋진 이름을 떠올리게 할 때가 있습니다. 이외에도 저자는 함수, 변수명을 지을 때 자바스크립트와 같은 동적 타입 언어라면 이름 앞에 타입을 드러내는 문자를 붙이는 스타일을 권장하기도 하였습니다. 예를 들어 손님 수를 의미하는 변수인 customer를 aCustomer라고 지으면 타입 예측이 더 쉬워진다고 조언하기도 했습니다. 

### 2. 책에 제시된 악취들 중 YAGNI와 가장 잘 어울리는 항목은 무엇인가(500자 이상)

  추측성 일반화(speculative Generality) 항목이 YAGNI와 가장 잘 어울립니다. 추측성 일반화는 나중에 필요할 것으로 예상되는 케이스를 처리하기 위해 미리 작성해둔 코드에서 풍기는 악취입니다. 

  YAGNI는 현시점까지 파악한 내용만을 가지고 변화에 대응하는 설계 방법을 의미합니다. 현시점에서 발생하지 않는 에러를 추측하고 대응하는 코드 즉, 추측성 일반화한 코드를 추가하는 것이 저자가 YAGNI 설계 방법을 설명할 때 언급했던 "유연성 메커니즘"의 한 예시라고 할 수 있습니다. "유연성 메커니즘"은 프로그램의 구조를 더욱 복잡하게 하는 경우가 많으므로 예상되는 에러와 관련된 부분을 더 깊게 이해할 때 대응하는 것이 좋습니다.

하는 일이 거의 없는 추상 클래스나, 쓸데없이 위임하는 코드, 그리고 사용되지 않는 매개변수를 제거하는 과정을 통해서 프로그램의 복잡도가 커지는 것을 방지하는 YAGNI 설계 방법과 상응한다고 생각합니다. 따라서 책에 제시된 악취 중 "추측성 일반화" 항목이 YAGNI와 가장 밀접한 연관이 있다고 생각합니다.

### 3. 주석과 악취의 관계에 대해 서술하시오 (500자 이상)

  주석은 코드를 설명하는 역할을 하지만, 불필요하거나 장황한 주석은 "악취"를 유발합니다. 저자는 주석이 코드를 잘 설명하는 데에 있는 "향기"를 입히는 역할이 아닌, 악취를 풍기는 코드의 "탈취제" 역할을 하는 것이 악취가 발생하는 원인이라고 했습니다.

  잘못 작성된 코드를 설명하고자 주석을 달게 되면, 주석이 장황해집니다. 책에서 저자는 어떤 코드에 주석이 필요하다는 생각이 든다면, 먼저 주석이 필요 없는 코드로 리팩터링하라고 말합니다. 주석이 많으면 악취를 유발하므로 저자가 언급한 "함수 추출하기" 기법을 활용하여 주석으로 설명하던 내용을 함수의 본문에 코드로 담고, "함수 바꾸기" 기법을 활용하여 함수의 이름을 통해서 의도를 파악할 수 있도록 해야 한다고 말했습니다.

  또한 저자는 주석은 잘못된 코드를 설명하는 용도가 아닌, 코드를 지금처럼 작성한 이유, 현재 진행 상황 및 확실하지 않은 부분을 설명하는 용도로 달아야 한다고 했습니다.

  요약하자면, 주석이 많으면 악취를 풍기게 되며, 잘 작성된 코드는 주석 없이도 이해가 가능하기 때문에 주석을 최소화할 수 있습니다. 따라서 저자가 제시한 기법을 토대로 리팩터링하여 코드에서 발생하는 악취를 제거한 후에 주석을 고민하는 것을 권장하며, 주석은 다음에 해당 부분을 수정할 프로그래머에게 코드에 관한 내용을 전달하는 용도로 사용하는 것이 좋습니다.

### 4. OOP 개념을 적극 적용하지 않아 함수와 변수들이 제각각 흩어진 코드가 있다. 이 들을 모아 하나의 클래스로 만들고 싶다. 이에 해당하는 ‘악취’에는 무엇이 있는가, 그 이유를 설명하라.(의도 답 : 데이터 뭉치, 산탄총 수술, 그러나 대부분의 예시가 제시된 리팩터링 과정에 적용 가능한 만큼, 설명이 충분히 설득력 있다면 점수 가능) (500자 이상)

  함수와 변수들이 제각각 흩어진 코드에는 "기능 편애(Feature Envy)", "산탄총 수술(Shotgun Surgery)"악취가 날 것으로 생각합니다. 

  특정 맥락에서 필요한 함수와 변수가 흩어져 있는 상황에서는 자기가 속한 곳이 아닌 다른 클래스 또는 모듈에 속한 함수 및 변수와 상호작용하는 일이 많을 때 발생하는 기능 편애 악취가 발생합니다. 이들을 하나의 클래스로 합치는 과정은 같은 맥락의 데이터를 모아주는 기능 편애 악취의 해결법이라고 할 수 있기 때문입니다.

  또한, 한 부분의 코드를 변경하면 해당 코드와 동일한 맥락에서 동작하는 모든 함수와 변수를 바꿔주어야 하는 산탄총 수술 악취가 난다고 생각합니다. 이 역시 하나의 클래스로 만드는 과정은 동일한 맥락에서 동작하지만 흩어져 있는 함수와 변수를 하나의 클래스로 모아서 "단계 쪼개기" 기법을 적용하거나 나중에 "함수 추출하기" 기법으로 더 좋은 형태로 분리하는 것을 계획할 수 있으므로 산탄총 수술 악취가 난다고 생각합니다.

### 5. 책에 제시된 악취들 중 서로 상충되는 두 악취를 한 쌍 고르고, 이 둘 사이에 적당한 지점을 찾는 법에 대해서 개인의 생각을 서술하시오. (500자 이상)

  저는 뒤엉킨 변경(Divergent Change)과 산탄총 수술(Shotgun Surgery)을 골랐습니다. 이 두 악취는 맥락을 잘 구분하지 못하여 발생하는 공통점이 있지만, 뒤엉킨 변경은 하나의 모듈이 서로 다른 이유로 인해 여러 가지 방식으로 변경되는 경우에 발생하며, 산탄총 수술은 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생합니다.

 저는 다른 맥락의 함수를 호출하는 빈도가 높다면 "뒤엉킨 변경"으로 판단할 것이고, 같은 맥락의 함수가 여러 곳에 흩어져 있다면 "산탄총 수술"로 판단할 것입니다. 

  뒤엉킨 변경은 맥락이 다른 코드가 한곳에 모여있기 때문에 발생하는 악취입니다. 따라서 같은 맥락의 코드끼리 분리한다면 처리 과정이 맥락별로 구분되기 때문에 소프트웨어의 구조가 더 자연스러워 질 것으로 예상합니다.

  산탄총 수술은 같은 맥락의 코드가 여러 부분에 흩어져 있어서 특정 부분에서 코드 변경이 발생하면 다른 곳에 존재하는 코드도 수정해야 해서 발생하는 악취입니다. 이러한 경우에 같은 맥락끼리 코드를 모아서 한 곳에서 코드 변경을 처리한다면 더 효율적으로 변경 사항을 반영할 수 있다고 생각합니다.

### 6. ‘가변 데이터’ 와 ‘전역 데이터’ 악취 각각에 대해, 그리고 가변 데이터가 동시에 전역 데이터인 악취에 대해 설명하시오. (500자 이상)



  가변 데이터는 변수의 값이 변경되는 경우, 다른 부분에서 기대한 값과 다른 데이터가 되면서 문제가 발생한다. 이러한 이유로 문제가 발생하면 어느 부분에서 값이 변경되었는지 추적하는 것이 매우 어려워집니다. "변수 캡슐화하기" 기법을 적용하여 지정된 함수를 거쳐야만 값이 수정될 수 있도록 설계하면, 이러한 에러 추적이 쉬워지고, 추후에 코드를 개선하기 쉬워집니다. 저자는 기본적으로 "변수 캡슐화하기" 방법을 적용하고, 상황에 따라 여러 방법을 적용하여 가변 데이터에 접근할 수 있는 범위를 최소화해서 이러한 문제를 해결할 수 있다고 했습니다.

  전역 데이터는 코드 어디서든 접근할 수 있으며, 값을 어디서 바꿨는지 찾아낼 방법이 없습니다. 버그가 발생하면 찾아내기가 매우 힘듭니다. 저자는 이를 예방할 수 있는 리팩터링 방법으로 "변수 캡슐화하기"라는 방법을 언급하였습니다. 

  전역 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근 제어를 통해서 해당 데이터에 접근할 수 있는 범위를 최소화해서 코드 추적을 쉽게 만든다고 했습니다. 

  전역 데이터가 가변적인 특성이 있다면 특히나 다루기 까다롭다고 했습니다. 전역 데이터는 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있어서 그나마 안전한 편이지만, 가변성을 지닌 전역 데이터가 많아진다면 이는 걷잡을 수 없는 상황이 발생할지도 모릅니다. 따라서 저자는 전역 데이터가 아주 조금만 있더라도 "캡슐화"를 통해서 이러한 상황을 방지하며, 소프트웨어의 변화에 효과적으로 대응할 수 있다고 하였습니다.

  가변 데이터, 전역 데이터, 그리고 가변성을 지닌 전역 데이터는 공통적으로는 "변수 캡슐화하기"를 통해서 데이터 접근 범위를 최소화하여 코드 추적을 쉽게 만들고 상황에 따라 다른 기법들을 적용하여 골치 아픈 버그를 사전에 방지해야 합니다.



