# Refactoring 이란?

> 소프트웨어의 겉보기 동작은그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법



### \# 정의

리팩토링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 따라서 리팩토링을 하는 동안에는 코드가 `항상 정상 작동하기 때문`에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다. `만약 리팩토링하다가 코드가 깨져서 며칠동안 고생했다고 하면 그것은 리팩토링이 아니다.`

###  \# 목적

코드를 이해하고 수정하기 쉽게 만드는 것이다. 리팩토링을 통해서 프로그램의 성능이 좋아질 수도 나빠질 수도 있기 때문에 성능 최적화와는 비슷하지만 목적이 다르다. 리팩토링의 목적은 `코드를 이해하고 수정하기 쉽게 만드는 것`이다. 성능 최적화는 오로지 속도 개선에만 신경 쓴다.

### \# 이유

1. 소프트웨어 설계가 좋아진다.
2. 소프트웨어를 이해하기 쉬워진다.
3. 버그를 쉽게 찾을 수 있다.
4. 프로그래밍 속도(생산성)을 높일 수 있다.



### \# 언제 리팩토링을 해야할까?

1. 준비를 위한 리팩토링: 기능을 쉽게 추가할 수 있도록 만들기
   * 리팩토링 하기 가장 좋은 시점은 `기능 추가 직전` : 지금까지 작성한 코드를 살펴보면서 리팩토링하면 다음 작업을 수월하게 할 부분을 리팩토링한다.
   
2. 이해를 위한 리팩토링: 코드를 이해하기 쉽게 만들기
   * 리팩토링을 통해서 내가 이해한 것을 코드에 반영하고, 내 생각이 맞았는지 검증(테스트)해보는 과정을 통해서 좀 더 깊은 수준까지 분석 및 이해할 수 있도록 한다.
   
3. 이해를 위한 리팩토링: 코드 이해하기 쉽게 만들기
4. 쓰레기 줍기 리팩토링
   * 이해를 위한 리팩토링 방법에서 변형된 형태인 코드 파악 중에 원래 하려던 작업과 관련없는 일에 너무 많은 시간을 빼앗기지 않도록 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 걸리는 일은 원래 하려던 작업을 마무리하고 처리하는 방법이다.  
   * `각각의 작은 단계가 코드를 깨뜨리지 않는다는` 리팩토링의 장점을 활용하여 버그를 발견한다면 조금이나마 개선을 해두고 원래 하려던 작업을 진행하는 것이 좋다. 작업을 잘게 나누면 장기간 리팩토링을 진행하더라도 그 사이 한 순간도 코드가 깨지지 않는다.

5. 계획된 리팩토링과 수시로 하는 리팩토링
   * 3번 까지의 리팩토링 방법은 기회가 될 때만 진행하는 것이다. 하지만 리팩토링은 수시로 진행해야 한다.  `보기 싫은 코드는 물론, 잘 작성된 코드 역시 많은 리팩토링을 거쳐야한다.`
   * 리팩토링 작업의 규모가 큰 경우을 비롯하여 예상보다 많은 공수가 예상되어 팀원 여럿이 달려들어야 할 정도로 빡센 작업이라면 리팩토링을 계획하고 진행할 수 있지만, 리팩토링은 대부분 드러나지 않게, 기회가 될 때마다 즉, `리팩토링과 기능 추가 작업을 따로 분리하지 않고 자연스럽게 녹여야 한다.`
6. 오래 걸리는 리팩토링
   * 공수가 많이 들고 골치 아픈 작업이어도 팀 전체가 리팩토링에 매달리는 것 보다 작업을 잘게 나누어 조금씩 해결해가는 방법이 대부분 효과적이다. `리팩토링이 코드를 깨뜨리지 않는 장점` 을 활용해야한다.
7. 리팩토링 하지 말아야할 때
   * 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩토링 하지 않는다. 
     e.g.) 외부 API 다루듯 호출해서 쓰는 코드
   * 해당 코드의 내부 동작을 이해해야 할 시점에 리팩토링을 한다.



### \# 리팩토링 시 고려할 문제

1. 리팩토링은 `개발 속도를 높이는 데`에 있다. 따라서 리팩토링은 오로지 경제적인 이유로 하는 것이다.
2. 코드 소유자가 다른 팀이라서 나에게 쓰기 권한이 없는 경우 리팩토링에 방해가 된다. 따라서 코드 소유권을 작은 단위로 나누기 보다는 팀 자체에 코드 소유권을 부여하여 팀원이라면 누구나 수정할 수 있도록 하는 것이 코드 소유권을 잘게 쪼개서 관리하는 것과 느슨하게 정하는 방식의 절충안이라고 할 수 있다.
3. 개인 브랜치에서 코드를 수정하면 마스터 브랜치로 머지하기 전까지 다른 사람이 변경 내용을 볼 수 없기 때문에 팀원 간의 수정 내용이 충돌이 날 우려가 크다. 따라서 `개인 브랜치에서 변경한 내용을 마스터 브랜치로 반영하는 기간을 짧게 할수록 좋으며`, 이 방식을 `지속적 통합`(Continuous Integration: CI) 또는 트렁크 기반 개발 (Trunk Based Development: TBD) 라고 한다. 특히 CI는 리팩토링과 궁합이 좋다.
4. 테스트 코드의 작성은 보다 빠르고 정확하고 효과적인 리팩토링을 도와준다.
5. 레거시 시스템을 파악할 때 리팩토링이 큰 도움이 된다. 레거시 시스템을 다룰 때에는 '틈새를 찾아서 테스트 코드를 추가'해야한다.



### \# 리팩토링, 아키텍쳐, 애그니(YAGNI)

리팩토링은 기존 코드의 설계를 개선할 수 있다. 리팩토링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응할 수 있도록 코드 베이스를 잘 설계해주는 것에 있다.  

기존 코드의 설계를 개선하는 다른 방법은 `유연성 메커니즘`이다. 유연성 메커니즘이란 예상되는 다양한 시나리오에 맞춰 미리 예상 상황들에 대응할 수 있는 코드를 작성하는 것인데, 이렇게 되면 소프트웨어의 복잡도가 높아지기 때문에 반드시 복잡도에 지장을 주는 것인지 아닌지에 대해 정확히 판단하고 추가해야한다. 리팩토링이 미뤄지면 힘들어진다는 확신이 다를 때에만 `유연성 메커니즘`을 추가한다. 

이런식으로 설계하는 방식을 간결한 설계, 점진적 설계 또는 애그니(You aren't going to need it: YAGNI) 등으로 부른다 .