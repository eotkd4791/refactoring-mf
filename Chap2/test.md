# Test

### 1. YAGNI에 대하여 서술하세요 (500자 이상)

  소프트웨어의 향후 변경에 유연하게 대처할 수 있도록 다양한 예상 시나리오에 대응할 수 있는 매개변수를 미리 추가하는 "유연성 메커니즘"이라는 방법이 있습니다. 이렇게 매개변수를 추가하다 보면 함수가 상당히 복잡해집니다. 이러한 유연성 메커니즘이 되려 변화에 대응하는 능력을 떨어뜨리는 경우가 많습니다. 

  리팩터링을 활용한다면 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 지금까지 파악한 요구사항만을 해결하는 소프트웨어를 구축합니다. 소프트웨어의 복잡도에 영향을 끼치지 않는 로직은 마음껏 추가하지만, 복잡도에 영향을 줄 수 있는 로직은 충분한 테스트 후에 추가하는 방법으로 요구사항 변화에 따른 소프트웨어 복잡도가 커지는 것을 최소화할 수 있습니다.

  이렇게 앞으로의 변화에 대해 추측하지 않고 현재 시점까지 파악한 내용을 토대로 변화에 대응하는 설계 방법을 YAGNI라고 부릅니다. YAGNI는 You Aren't Going to Need It의 줄임말로 소프트웨어 복잡도를 최소화하고 요구사항 변화에 신속하게 대응할 수 있습니다.

지속적 통합(CI), 테스트 코드, 리팩토링은 YAGNI 설계의 토대가 되기 때문에 세 가지 실천법의 적절한 조화가 필요합니다.



### 2. 리팩터링을 해야 할 때가 언제인지 저자의 견해를 서술하시요(500자 이상)

  저자는 기능 추가하기 전, 코드를 수정하기 전에 리팩터링을 해야 한다고 했습니다. 기능을 추가하기 위한 작업을 더욱 수월하게 만들어줄 수정 사항이 있는지 확인하고, 중복을 제거하는 리팩터링을 진행한 후에 본 작업을 시작한다고 했습니다. 또한, 코드를 수정하기 위해서는 반드시 수정하고자 하는 코드가 어떠한 임무를 수행하는지 파악을 해야 합니다. 코드의 역할 분석 중에 리팩터링을 하면 더 효율적으로 작동할 여지가 있는지를 파악한 후, 리팩터링하고 코드 수정 작업을 시작한다고 하였습니다. 저자는 특히 코드를 분석할 때 리팩터링을 하면 미처 파악하지 못한 깊은 수준까지 코드를 이해할 수 있는 장점이 있다고 하였습니다.

  저자는 기능 추가 전, 코드 수정 전 이외의 경우에도 리팩터링을 해야 할 경우가 있다고 했습니다. 코드를 파악하던 중에 로직이 쓸데없이 복잡하거나, 비슷한 일을 하는 함수가 중복 정의되어 있는 경우에 간단히 수정할 수 있는 것은 즉시 고치고, 공수가 들 것 같은 일은 원래 하려던 일을 마무리하고 돌아와서 처리하는 것이 좋다고 하였습니다.

  리팩터링은 따로 일정을 잡고 진행하는 것이 아니라, 프로그래밍 과정에 자연스럽게 녹여내는 것이 좋으며, 리팩터링을 진행할 별도의 사람을 두는 것이 아니라, 팀원 누구든 간에 리팩터링이 필요한 코드와 관련된 작업을 진행할 때마다 원하는 방향으로 조금씩 드러나지 않게, 기회가 될 때마다 개선하는 것을 추천하였습니다.



### 3. 설계 단계에서 모든 요구사항을 알기 힘드므로 아키텍쳐의 변경이 필요할 때가 많다. 이를 해결하기 위한 저자의 견해를 서술하시오 (500자 이상)

  저자는 주기적이고 꾸준한 리팩터링을 통해서 요구사항 변화에 더 유연하게 대응할 수 있다고 했습니다. 리팩터링이 가진 특징은 리팩터링 적용 전과 후의 프로그램의 겉보기 동작은 똑같이 유지된다는 점이며, 이를 활용해야 한다고 했습니다. 또한, 테스팅이 뒷받침된 리팩터링을 진행해야 한다고 했습니다.

  책에서 저자는 YAGNI 설계 방식을 소개하며, 예상되는 변화에 잘 대응할 수 있을지를 추측하지 않고, 오직 현재까지 파악한 요구사항만을 해결하는 방식으로 소프트웨어를 구축해야 한다고 했습니다. 소프트웨어 복잡도를 높이고 변화에 대응하는 능력을 떨어뜨리는 유연성 메커니즘을 필요에 의해서만 추가하고, 예상되는 변화는 다음에 해당 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 더 효율적이라고 말했습니다.

  요약하면 저자는 탄탄한 테스팅이 뒷받침된 리팩터링을 하되, 예상되는 변화보다는 현재 발생한 문제에 비중을 두고 처리하는 것이 좋으며, 리팩터링을 미루면 매우 힘들어진다는 확신이 들 때만 유연성 메커니즘을 추가하는 방식으로 진행해야 한다고 했습니다.



### 4. 리팩터링으로 이점이 무엇인지 저자의 관점에서, 회사 윗사람을 설득시킨다는 생각으로 서술하세요 (500자 이상)

  리팩터링은 단순히 코드를 더 아름답게 만들기 위해서가 아니라, 오직 경제적인 이유로 하는 것입니다. 소프트웨어를 리팩터링하면 코드의 흐름을 더욱 깊이 있게 파악할 수 있습니다. 그로 인해 버그를 쉽게 찾을 수 있으며,  빠르고 정확하게 기능 추가 및 새로운 요구사항을 반영할 수 있습니다. 

  또한, 리팩터링은 또한 내부 설계를  짜임새있게 구성할 수 있습니다. 리팩터링을 하지 않는 팀은 초기에 빠르게 개발할 수 있지만, 추가 요구사항 반영 및 기능 추가를 거듭할수록 버그가 발생하고, 기존의 구조를 수정하지 않고서는 개발이 진행조차 되지 않는 상황에 맞닥뜨릴 수 있습니다. 반면, 리팩터링을 꾸준히 거친 코드는 내부 설계가 잘 되어 있으므로 어느 부분을 어떻게 고쳐서 새로운 기능을 추가하는지에 대한 빠르고 정확한 작업이 가능합니다. 프로그램의 설계나 요구사항이 바뀌더라도 설계를 계속해서 지속할 수 있으며, 변화에 유연하게 대처할 수 있습니다.

 리팩터링은 언제든 중단하고 재개할 수 있으며, 리팩터링의 각각의 단계가 코드를 깨뜨리지 않기 때문에 프로그램 개발 프로세스에 리팩터링을 자연스럽게 녹여내어 하나의 과정으로 여기고 업무를 진행한다면 경제적인 측면에서 많은 이익을 볼 수 있다고 생각합니다.  



###  5. 리팩터링이 어떻게 하여 소프트웨어의 성능에 도움이 될 수 있는지 저자의 관점을 서술하시오 (500자 이상)

저자는 소프트웨어의 성능을 저하하는 부분들은 전체적으로 존재하는 것이 아닌, 극히 일부분에 존재한다고 했습니다. 따라서 코드 전체를 고르게 최적화하는 것은 매우 비효율적이며, 코드를 이해하기 어렵게 만드는 것에 시간을 투자한 것과 같다고 하였습니다. 

  성능 개선을 위한 코드 수정을 하다 보면 코드가 오염되며 프로그램의 복잡도가 증가하는 반면에 리팩터링을 하면 소프트웨어가 느려질 수도 있지만, 성능 저하의 원인이 되는 부분을 찾아내어 해당 부분에만 집중하기 때문에 보다 효율적으로 성능 최적화를 진행할 수 있다고 하였습니다. 따라서 적은 노력으로도 두드러진 효과를 볼 수 있다고 하였습니다.

  또한, 성능을 최적화하는 단계에서 이미 리팩터링이 되어 있다면 기능 추가 및 확장 등의 작업이 매우 쉬워지므로 시간 측면에서 이득을 볼 수 있고, 이에 따라 성능 개선에 투자할 시간을 벌 수 있다고 하였습니다. 리팩토링이 잘 되어 있는 프로그램은 더 쉽고 깊이 있게 분석할 수 있으므로 성능을 측정하는 프로파일러가 지적해주는 코드의 범위가 더 좁아지며, 리팩토링을 거친 깔끔한 코드로 인해서 성능 개선에 관련된 아이디어가 잘 떠오를 것이라고 하였습니다. 이러한 이유로 저자는 리팩터링이 소프트웨어 성능 향상에 기여한다고 하였습니다.

